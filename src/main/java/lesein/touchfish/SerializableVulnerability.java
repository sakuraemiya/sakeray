package lesein.touchfish;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.util.Base64;

/**
 * @author WangJie
 * @date 2022/6/14
 * 序列化漏洞
 */
public class SerializableVulnerability {

    public static class Command implements Serializable {
        private String cmd;

        public String getCmd() {
            return cmd;
        }
        public void setCmd(String cmd) {
            this.cmd = cmd;
        }
        // 执行反序列化方法时执行自定义命令
        private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException{
            //执行默认的readObject()方法
            in.defaultReadObject();
            //执行命令
            Runtime.getRuntime().exec(this.getCmd());
        }
    }



    public static void main(String[] args) {
        Command command = new Command();
        command.setCmd("calc");
        System.out.println("序列化前: " + command.getCmd());

        ByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream();
        // 将对象序列化为字节数组
        try {
            ObjectOutputStream objectOutputStream=new ObjectOutputStream(byteArrayOutputStream);
            objectOutputStream.writeObject(command);
        } catch (IOException e) {
            e.printStackTrace();
        }
        // 将字节数组进行base64编码
        final String data = Base64.getEncoder().encodeToString(byteArrayOutputStream.toByteArray());
        System.out.println("序列化后: " + data);
        // 将base64编码的数据再解码为字节数组
        final byte[] bytes = Base64.getDecoder().decode(data.getBytes(StandardCharsets.UTF_8));
        // 将字节数组反序列化为对象
        ByteArrayInputStream b = new ByteArrayInputStream(bytes);
        try {
            ObjectInputStream input = new ObjectInputStream(b);
            final Command obj = (Command) input.readObject();
            System.out.println("反序列化: " + obj.getCmd());
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }

}
